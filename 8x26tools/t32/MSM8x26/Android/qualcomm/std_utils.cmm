//============================================================================
//  Name:                                                                     
//    std_utils.cmm
//
//  Description:                                                              
//    Script to house common utilities or macros
//
//  Usage
//  do std_utils < Name of utility > < Arguments for the utlity >
//
//	e.g. do std_utils removeslash exit c:\dropbox\ will return c:\dropbox to the caller
//	e.g  do std_utils executecmm exit std_memorymap will execute std_memorymap.cmm or exit if not found.
//                                                                            
// Copyright (c) 2012 - 2014 by QUALCOMM, Incorporated.  All Rights Reserved.        
//
//
//
//
//                      EDIT HISTORY FOR FILE
//  This section contains comments describing changes made to the module.
//  Notice that changes are listed in reverse chronological order.
//
// when         who     	what, where, why
// --------     ---        --------------------------------------------------------
// 10/19/2012 AJCheriyan   Fixed bug in CHECKARGS. Added one more arg
// 09/12/2012 AJCheriyan   Fixed menu option in EXECUTESCRIPT
// 07/19/2012 AJCheriyan   Added HWIO utilities
// 07/14/2012 AJCheriyan   Added new utilities - LOADBIN, SAVEBIN, CHECKARGS
// 07/09/2012 AJCheriyan   Added 2 extra arguments to execute cmm util
// 03/15/2011 AJCheriyan   Added util to remove slash, execute cmm file
// 03/15/2011 AJCheriyan   Created for MSM8660 
//


ENTRY &UTILITY &OPTION &IARG0 &IARG1 &IARG2 &IARG3 &IARG4 &IARG5 &IARG6 &IARG7 &IARG8 &IARG9

//	Locals: Local Variables
//	Input Arguments
//LOCAL &UTILITY &OPTION &IARG0 &IARG1 &IARG2 &IARG3 &IARG4

//	Return values to the caller along with success / fail value specific to utility
LOCAL &PASS &RVAL0 &RVAL1 &RVAL2

// Name of the utility we are calling
LOCAL &SUBROUTINE

// Any subroutine specific options
// Default exists for each subroutine
LOCAL &OPTION

// Input Argument 0 is the name of the utility
&SUBROUTINE="&UTILITY"

IF ("&SUBROUTINE"=="")
(
	PRINT %ERROR "WARNING: UTILITY &UTILITY DOES NOT EXIST."
	GOTO EXIT
)
ELSE
(
	// This should be created by some top level script. The setupenv for each proc would
	// set this up
 	AREA.SELECT

 	// Debug Print Statement
	// PRINT "&SUBROUTINE &OPTION &IARG0 &IARG1 &IARG2 &IARG3 &IARG5 &IARG6 &IARG7"
    // Call the required utility
	GOSUB &SUBROUTINE &OPTION &IARG0 &IARG1 &IARG2 &IARG3 &IARG4 &IARG5 &IARG6 &IARG7 &IARG8 &IARG9
	ENTRY &PASS &RVAL0 &RVAL1 &RVAL2

	GOTO EXIT
	
)

// Function: REMOVESLASH
// Removes a trailing backslash or forward slash from the string
//
// First argument determines to the number of arguments to process.
REMOVESLASH:
	ENTRY &OPTION &ARG0 &ARG1 &ARG2
	
	LOCAL &COUNT
	&COUNT=0x0
	
	IF (("&ARG0"!="")&&((STRING.CUT("&ARG0",STRING.LEN("&ARG0")-1)=="\")||(STRING.CUT("&ARG0",STRING.LEN("&ARG0")-1)=="/")))
	(
		&RVAL0=STRING.CUT("&ARG0",-1)
		&COUNT=&COUNT+1.
	)
	ELSE
	(
		&RVAL0="&ARG0"
	)
	
	IF (("&ARG1"!="")&&((STRING.CUT("&ARG1",STRING.LEN("&ARG1")-1)=="\")||(STRING.CUT("&ARG1",STRING.LEN("&ARG1")-1)=="/")))
	(
		&RVAL1=STRING.CUT("&ARG1",-1)
		&COUNT=&COUNT+1.
	)
	ELSE
	(
		&RVAL1="&ARG1"
	)
	
	IF (("&ARG2"!="")&&((STRING.CUT("&ARG2",STRING.LEN("&ARG2")-1)=="\")||(STRING.CUT("&ARG2",STRING.LEN("&ARG2")-1)=="/")))
	(
		&RVAL2=STRING.CUT("&ARG2",-1)
		&COUNT=&COUNT+1.
	)
	ELSE
	(
		&RVAL2="&ARG2"
	)
	
	// Return the values to caller
	RETURN &COUNT &RVAL0 &RVAL1 &RVAL2

// Function: CHECKARGS
// Checks an argument value against a list of possible values
// Typically used
CHECKARGS:
	ENTRY &ACTION &ARGVAL &POSS1 &POSS2 &POSS3 &POSS4 &POSS5 &POSS6 &POSS7 &POSS8 &POSS9

	LOCAL &RVALUE
	&RVALUE="FALSE"

	// Check if all the possibilities are empty
	IF (("&POSS1"!="")||("&POSS2"!="")||("&POSS3"!="")||("&POSS4"!="")||("&POSS5"!="")||("&POSS6"!="")||("&POSS7"!="")||("&POSS8"!="")||("&POSS9"!=""))
	(
		IF ("&ARGVAL"=="&POSS1")
		(
			&RVALUE="TRUE"
		)
	    IF ("&ARGVAL"=="&POSS2")
	    (
	    	&RVALUE="TRUE"
	    )
        IF ("&ARGVAL"=="&POSS3")
	    (
	    	&RVALUE="TRUE"
	    )
		IF ("&ARGVAL"=="&POSS4")
	    (
	    	&RVALUE="TRUE"
	    )
		IF ("&ARGVAL"=="&POSS5")
	    (
	    	&RVALUE="TRUE"
	    )
		IF ("&ARGVAL"=="&POSS6")
	    (
	    	&RVALUE="TRUE"
	    )
		IF ("&ARGVAL"=="&POSS7")
	    (
	    	&RVALUE="TRUE"
	    )
		IF ("&ARGVAL"=="&POSS8")
	    (
	    	&RVALUE="TRUE"
	    )
            IF ("&ARGVAL"=="&POSS9")
	    (
	    	&RVALUE="TRUE"
	    )
	)
	// The check failed. We want to know how to exit 
	IF (("&ACTION"!="EXIT")&&("&RVALUE"!="TRUE"))
	(
		PRINT %ERROR "&ARGVAL does not match values: &POSS1 &POSS2 &POSS3 &POSS4 &POSS5 &POSS6 &POSS7 &POSS8 &POSS9"
		GOTO &ACTION
	)
	// Else, return gracefully
	RETURN &RVALUE


// Function: SAVEMMU
// Saves the MMU for a particular type of processor
SAVEMMU:
	ENTRY &PROCTYPE &DIRNAME &FILENAME
	
	LOCAL &FULLPATH
	&FULLPATH="&DIRNAME"+"/&FILENAME"
	
	// We always append to an existing file
	OPEN #1 "&FULLPATH" /CREATE
	
	IF ("&PROCTYPE"=="ARM")
	(
	 	WRITE #1 "// MMU Settings for ARM Processor"
	 	WRITE #1 "PER.S C15:0x3 %LONG "+FORMAT.HEX(DATA.LONG(C15:0x3), 8)
		WRITE #1 "PER.S C15:0x2 %LONG "+FORMAT.HEX(DATA.LONG(C15:0x2), 8)
		WRITE #1 "PER.S C15:0x102 %LONG "+FORMAT.HEX(DATA.LONG(C15:0x102), 8)
		WRITE #1 "PER.S C15:0x202 %LONG "+FORMAT.HEX(DATA.LONG(C15:0x202), 8)
		WRITE #1 "PER.S C15:0x1 %LONG "+FORMAT.HEX(DATA.LONG(C15:0x1), 8)
		WRITE #1 "ENDDO"
	)

	CLOSE #1

	RETURN


// Function: LOADBIN
// Loads a binary in some directory to a specified address
// Other arguments not used
LOADBIN:
	ENTRY &DIRNAME &FILENAME &STARTADDR &OFFSET &SIZE
	
	PRINT "&DIRNAME &FILENAME &STARTADDR &OFFSET &SIZE"
	
	LOCAL &FULLPATH 
	&FULLPATH="&DIRNAME"+"/&FILENAME"
	IF ("&OFFSET"=="")
	(	
		D.LOAD.BINARY &FULLPATH &STARTADDR 
	)
	ELSE
	(
	 	IF (OS.FILE.SIZE("&FULLPATH")<&OFFSET)
		(
			D.LOAD.BINARY &FULLPATH &STARTADDR
		)
		ELSE
		(
			D.LOAD.BINARY &FULLPATH &STARTADDR++&SIZE /SKIP &OFFSET
		)		
	)

	RETURN "TRUE"

// Functions: MEMCOPY
// Copies a chunk of memory from one location to another	
MEMCOPY:
	ENTRY &DEST_ADDR &SOURCE_ADDR &SIZE

	DATA.COPY &SOURCE_ADDR++&SIZE &DEST_ADDR

	RETURN "TRUE"

// Function: SAVEBIN
// Saves a binary at some specified address to a directory
SAVEBIN:
	ENTRY &DIRNAME &FILENAME &STARTADDR &SIZE
	
	PRINT "&DIRNAME &FILENAME &STARTADDR &SIZE"
	
	LOCAL &FULLPATH 
	&FULLPATH="&DIRNAME"+"/&FILENAME"
SECURE:
	ON ERROR GOTO NSECURE
	D.SAVE.BINARY &FULLPATH EZAHB:&STARTADDR++(&SIZE-1)
	GOTO EXIT_SAVEBIN
NSECURE:
	ON ERROR
	D.SAVE.BINARY &FULLPATH EAHB:&STARTADDR++(&SIZE-1)
EXIT_SAVEBIN:
	RETURN "TRUE"

// Function: ATTACHPROC
// Attach to a T32 session after it checks
ATTACHPROC:
	IF (SYSTEM.UP())
	(
		IF (!STATE.RUN())
		(
			GO
		)
	)
	ELSE
	(
		// Bring the system up and reset registers to be safe
		SYS.MODE ATTACH
		SYS.MODE ATTACH
		IF (!STATE.RUN())
		(
			GO
		)

	)

	RETURN

// Function: DETACHPROC
// Disconnect a T32 session
DETACHPROC:
	IF (SYSTEM.UP())
	(
		SYS.DOWN
	)

	RETURN

// Function: BREAKPROC
// Attach and stop a T32 session
BREAKPROC:
	// Attach to the processor
	// Add second attach to prevent fickle behavior because of JTAG clock issues
    SYS.MODE ATTACH
   	SYS.MODE ATTACH	

	//Break the processor
	IF (RUN())
	(
		BREAK
	)

	RETURN


// Function: SAVEREGS
// Stores a processors registers to a particular file
SAVEREGS:
    ENTRY &DIRNAME &FILENAME

	LOCAL &FULLPATH
	&FULLPATH="&DIRNAME"+"/&FILENAME"
	STORE &FULLPATH HEX REGISTER

	RETURN "TRUE"

// Macros for reading and writing to registers
// Warning: The symbols used must exist and must conform
// to the expected format. No error checking here
//
// Write to a particular register
// Format: HWIO_OUT <register> <value>
HWIO_OUT:
 	ENTRY &REG &VALUE

	LOCAL &REGNAME
	
	&REGNAME="HWIO_"+"&REG"+"_ADDR"
 	DATA.SET EAHB:&REGNAME %LONG &VALUE
 RETURN

// Write to a particular register field
// Format: HWIO_OUTF <register> <field> <value>
HWIO_OUTF:
 	ENTRY &REG &FIELD &VALUE
 
 	LOCAL &REGNAME &READ &DATA &MASK &SHFT
 	
	&REGNAME="HWIO_"+"&REG"+"_ADDR"
 	&MASK="HWIO_"+"&REG"+"_&FIELD"+"_BMSK"
 	&SHFT="HWIO_"+"&REG"+"_&FIELD"+"_SHFT"
	&READ=DATA.LONG(EAHB:&REGNAME)
 	&DATA=(&READ&~address.offset(&MASK))|(&VALUE<<address.offset(&SHFT))
 	DATA.SET EAHB:&REGNAME %LONG &DATA
 RETURN

// Read a register
// Format: HWIO_IN <register> <field>
HWIO_IN:
	ENTRY &REG
	
	LOCAL &REGNAME &DATA
	
	&REGNAME="HWIO_"+"&REG"+"_ADDR"
	&DATA=DATA.LONG(EAHB:&REGNAME)
 RETURN &DATA

// Read a particular register field 
// Format: HWIO_INF <register> <field> <value>
HWIO_INF:
 	ENTRY &REG &FIELD
	
	LOCAL &REGNAME &READ &DATA &MASK &SHFT
	
	&REGNAME="HWIO_"+"&REG"+"_ADDR"
	&MASK="HWIO_"+"&REG"+"_&FIELD"+"_BMSK"
 	&SHFT="HWIO_"+"&REG"+"_&FIELD"+"_SHFT"
	&READ=DATA.LONG(EAHB:&REGNAME)
    &DATA=(&READ&address.offset(&MASK))>>address.offset(&SHFT)
 RETURN &DATA

// Returns the address of a particular register
// Format: HWIO_ADDR <register>
HWIO_ADDR:
	ENTRY &REG
	LOCAL &VAR
	&VAR="HWIO_"+"&REG"+"_ADDR"
	&VAR=address.offset(&VAR)
	RETURN &VAR

// Performs an indexed write to a register
// Format: HWIO_OUTI <base register> <index> <value>
HWIO_OUTI:
	ENTRY &REG &INDEX &DATA
	LOCAL &REG1 &REG2 &SIZE &REGADDR
	&REG1="HWIO_"+"&REG"+"0_ADDR"
	&REG2="HWIO_"+"&REG"+"1_ADDR"
	&SIZE=address.offset(&REG2)-address.offset(&REG1)
	&REGADDR=address.offset(&REG1)+(&SIZE*&INDEX)
	DATA.SET EAHB:&REGADDR %LONG &DATA
	RETURN
	
// Function: FILEXIST
// Checks if a file exists in a particular location
// First Arg - Action in case of failure
// Second Arg - Directory name 
// Third Arg - Filename
// Other Args - not used
FILEXIST:
    ENTRY &ACTION &DIRNAME &FILENAME &ARG0 &ARG1
	
	LOCAL &FULLPATH &RVALUE
	&RVALUE="FALSE"
	IF ("&FILENAME"=="")
	(
		// Assume user has given the full path to the file
		// in the directory name
		&FULLPATH="&DIRNAME"
	)
	ELSE
	(
		&FULLPATH="&DIRNAME"+"/&FILENAME"
	)

	IF (OS.FILE(&FULLPATH))
    (
		&RVALUE="TRUE"
	)
	ELSE
	(
        PRINT %ERROR "File &FULLPATH does not exist"
		&RVALUE="FALSE"
	)

	// The check failed. We want to know how to exit 
	IF (("&ACTION"!="EXIT")&&("&RVALUE"!="TRUE"))
	(
		GOTO &ACTION
	)
	// Else, return gracefully
	RETURN &RVALUE





//	Function: EXECUTESCRIPT
//	If a cmm script exists, it will execute it.
//
// 	Second argument determines course of action to be taken in case of error. 
//	EXIT - Normal exit. End that particular script
//	FATALEXIT - Fatalexit. End the entire program.
EXECUTESCRIPT:
	ENTRY &ACTION &SCRIPTNAME &ARG0 &ARG1 &ARG2 &ARG3
	
	LOCAL &EXTENSION
	LOCAL &FILENAME
	LOCAL &CWDIR
	
	IF (("&SCRIPTNAME"!=""))
	(
		&EXTENSION=OS.FILE.EXTENSION("&SCRIPTNAME")
		IF ("&EXTENSION"=="")
		(
			// Assume it is a cmm script.
			&EXTENSION=".cmm"
			// Append the extension to the scriptname then
			&FILENAME="&SCRIPTNAME"+"&EXTENSION"
		)
		ELSE
		(
			// The utility was used with the full filename. So filename is same as scriptname
			&FILENAME="&SCRIPTNAME"
		)
	)
	
	
	// Check if CMM and execute
	IF (OS.FILE("&FILENAME")&&("&EXTENSION"==".cmm"))
	(
		&CWDIR=OS.PWD()
	 	CD.DO "&FILENAME" &ARG0 &ARG1 &ARG2 &ARG3
		&PASS=0x1
		CD &CWDIR

		// Take the action based on the input
		GOTO &ACTION
	)

	// Check if MEN and execute
	IF (OS.FILE("&FILENAME")&&("&EXTENSION"==".men"))
	(
		// First delete
	 	MENU.DELETE "&FILENAME"
		// Then add
	 	MENU.REPROGRAM "&FILENAME"
	 	&PASS=0x1
		
		// Take the action based on the input
		GOTO &ACTION
	
	)
	
	// Check if T32 extension and execute
	IF (OS.FILE("&FILENAME")&&("&EXTENSION"==".t32"))
	(
	 	TASK.CONFIG "&FILENAME" 
		&PASS=0x1

		// Take the action based on the input
		GOTO &ACTION
	)

	// Check if emm and execute
	IF (OS.FILE("&FILENAME")&&("&EXTENSION"==".emm"))
	(
		// We assume the encrypted script is using the script name as the encryption key
		// This saves us one argument
		&CWDIR=OS.PWD()
		DODECRYPT "&FILENAME" "&SCRIPTNAME" &ARG0 &ARG1 &ARG2 &ARG3
		&PASS=0x1
		CD &CWDIR

		// Take the action based on the input
		GOTO &ACTION
	)
	ELSE
	(
		// Will enter this section only if the file did not exist / error condition
		&PASS=0x0
		PRINT %ERROR "&SCRIPTNAME not found"
		GOTO &ACTION
	)
	
	// Not required as input determines the return path
	RETURN
	
//	Function: Exit
//	Return with return values	
EXIT:
	ENDDO &PASS &RVAL0 &RVAL1 &RVAL2

//	Function: Fatalexit
//	Return without return values	
FATALEXIT:
	END
